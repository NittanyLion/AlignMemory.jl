var documenterSearchIndex = {"docs":
[{"location":"#MemoryLayouts.jl","page":"Home","title":"MemoryLayouts.jl üß†‚ö°","text":"Optimize your memory layout for maximum cache efficiency.\n\nDocumentation for MemoryLayouts.","category":"section"},{"location":"#The-Problem-vs.-The-Solution","page":"Home","title":"üöÄ The Problem vs. The Solution","text":"Standard collections in Julia (Dicts, Arrays of Arrays, structs) often scatter data across memory, causing frequent cache misses. MemoryLayouts.jl packs this data into contiguous blocks.","category":"section"},{"location":"#How-it-works","page":"Home","title":"üîÆ How it works","text":"Function Description Analogy\nlayoutmem( x ) Aligns immediate fields of x Like copy( x ) but packed\ndeeplayoutmem( x ) Recursively aligns nested structures Like deepcopy( x ) but packed","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"The package provides two exported functions: layoutmem and deeplayoutmem. The distinction is that layoutmem only applies to top level objects, whereas deeplayoutmem applies to objects at all levels. The two examples below demonstrate their use.","category":"section"},{"location":"#SIMD-Alignment","page":"Home","title":"SIMD Alignment","text":"Both layoutmem and deeplayoutmem accept an optional alignment keyword argument (default 1). This allows you to specify the byte alignment for the start of each array in the contiguous memory block.\n\nProper memory alignment is crucial for maximizing performance with SIMD (Single Instruction, Multiple Data) instructions (e.g., AVX2, AVX-512).\n\nAVX2 typically requires 32-byte alignment.\nAVX-512 typically requires 64-byte alignment.","category":"section"},{"location":"#Example","page":"Home","title":"Example","text":"using MemoryLayouts\nstruct MyData\n    a::Vector{Float64}\n    b::Vector{Float64}\nend\n\ndata = MyData( rand( 100 ), rand( 100 ) )\n\n# Align for AVX-512 (64-byte alignment)\naligneddata = layoutmem( data; alignment = 64 )\n\n# Verify alignment\npointer( aligneddata.a ) # Will be a multiple of 64\npointer( aligneddata.b ) # Will be a multiple of 64","category":"section"},{"location":"#Example-for-layoutmem","page":"Home","title":"Example for layoutmem","text":"The example below demonstrates how to use layoutmem.\n\nusing MemoryLayouts, BenchmarkTools, StyledStrings\n\nfunction original( A = 10_000, L = 100, S = 5000)\n    x = Vector{Vector{Float64}}( undef, A )\n    s = Vector{Vector{Float64}}( undef, A )\n    for i ‚àà 1:A\n        x[i] = rand( L )\n        s[i] = rand( S )\n    end\n    return x\nend\n\nfunction computeme( X )\n    Œ£ = 0.0\n    for x ‚àà X \n        Œ£ += x[5] \n    end\n    return Œ£\nend\n\nprint( styled\"{(fg=0xff9999):original}: \" ); @btime computeme( X ) setup=(X = original();)\nprint( styled\"{(fg=0x99ff99):layoutmem}: \" ); @btime computeme( X ) setup=(X = layoutmem( original());)\n;","category":"section"},{"location":"#Example-for-deeplayoutmem","page":"Home","title":"Example for deeplayoutmem","text":"The example below illustrates the use of deeplayoutmem.\n\nusing MemoryLayouts, BenchmarkTools, StyledStrings\n\n\nstruct ùíÆ{X,Y,Z}\n    x :: X\n    y :: Y \n    z :: Z\nend\n\n\nfunction original( A = 10_000, L = 100, S = 5000)\n    x = Vector{Vector{Float64}}( undef, A )\n    s = Vector{Vector{Float64}}( undef, A )\n    for i ‚àà 1:A\n        x[i] = rand( L )\n        s[i] = rand( S )\n    end\n    return ùíÆ( [x[i] for i ‚àà 1:div( A, 3 )], [ x[i] for i ‚àà div( A, 3 )+1:div( 2*A, 3 )], [x[i] for i ‚àà div( 2*A, 3 )+1:A ] )\nend\n\nfunction computeme( X )\n    Œ£ = 0.0\n    for x ‚àà X.x  \n        Œ£ += x[5] \n    end\n    for y ‚àà X.y \n        Œ£ += y[37]\n    end\n    for z ‚àà X.z \n        Œ£ += z[5] \n    end\n    return Œ£\nend\n\nprint( styled\"{(fg=0xff9999):original}: \" ); @btime computeme( X ) setup=(X = original();)\nprint( styled\"{(fg=0x99ff99):layoutmem}: \" ); @btime computeme( X ) setup=(X = layoutmem( original());)\nprint( styled\"{(fg=0x9999ff):deeplayoutmem}: \" ); @btime computeme( X ) setup=(X = deeplayoutmem( original());)\n;","category":"section"},{"location":"#Compatibility-and-Extensions","page":"Home","title":"üîå Compatibility & Extensions","text":"MemoryLayouts.jl is further compatible with \nAxisKeys\nInlineStrings\nNamedDimsArrays \nOffsetArrays\nthis assumes that those packages are loaded by the user","category":"section"},{"location":"#Function-documentation","page":"Home","title":"Function documentation","text":"","category":"section"},{"location":"#MemoryLayouts.layoutmem","page":"Home","title":"MemoryLayouts.layoutmem","text":"layoutmem(s; exclude = Symbol[], alignment::Int=1)\n\nlayoutmem aligns the memory of arrays within the object s, whose type should be one of struct, AbstractArray, or AbstractDict\n\nlayoutmem creates a new instance of s (or copy of s) where the arrays are stored contiguously in memory.\n\nThe alignment keyword argument specifies the memory alignment in bytes. This is particularly useful for SIMD operations, where aligning data to 16, 32, or 64 bytes can improve performance.\n\nExcluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:aligned arrays share a single contiguous memory block\nresizing any of the arrays (push!, append!) will break this contiguity for that array (it will be reallocated elsewhere)\nContiguity is maintained until an array is resized or reassigned\n\n\n\n\n\n","category":"function"},{"location":"#MemoryLayouts.deeplayoutmem","page":"Home","title":"MemoryLayouts.deeplayoutmem","text":"deeplayoutmem( x; exclude = Symbol[], alignment::Int=1 )\n\ndeeplayoutmem recursively aligns memory of arrays within x and its fields\n\nUnlike layoutmem, which only aligns the immediate fields/elements of x, deeplayoutmem traverses the structure recursively.  In other words, deeplayoutmem is to layoutmem what deepcopy is to copy.\n\nThe alignment keyword argument specifies the memory alignment in bytes. This is particularly useful for SIMD operations, where aligning data to 16, 32, or 64 bytes can improve performance.\n\nExcluded items are preserved as-is (or deep-copied in some contexts) but not packed into the contiguous memory block.\n\nwarning: important implementation details\nUsers should be mindful of the following important implementation details:aligned arrays share a single contiguous memory block\nresizing any of the arrays (push!, append!) will break this contiguity for that array (it will be reallocated elsewhere)\nContiguity is maintained until an array is resized or reassigned\n\n\n\n\n\n","category":"function"}]
}
